/*
 *  1. 연산자
 *    1) 연산자의 종류
 *    	1-1) 단항연산자 (***중요)
 *    	     = ***증감연산자 (++,--)
 *           = ***부정연산자 (!)
 *           = 부호연산자 (+,-)
 *           = ***형변환연산자 ((type))
 *           			type ==> int, byte, char, double, long...
 *           			(int) (byte) (char) (double) (long)
 *           			데이터형을 변경해서 연산처리가 가능하게 만든다 (연산의 핵심: 데이터형이 동일해야함)
 *      1-2) 이항연산자 
 *      	 = ***산술연산자 (+,-,*,/,%) => 형변환
 *      			   /
 *      			   ==> 0으로 나눌 수 없다
 *      			   ==> 정수/정수 = 정수 ==> 5/2=2 (정수 나누기 정수는 정수, 소수점이 사라짐)
 *      			   %
 *      			   ==> 나머지 값을 가지고 옴 (배수 구하기, 나머지가 0일 때)
 *      			   ==> 1) 5%2 (1) (5를 2로 나누고 나머지를 가지고 와라, 즉 1)
 *      			   ==> 2) 5%-2 (1) 
 *      			   ==> 3) -5%2 (-1)
 *                     ==> 4) -5%-2 (-1)
 *                     남는 것은 왼쪽 부호를 따라간다.\         
 *      	 = 비트연산자 (&,|,^)	
 *           = 쉬프트연산자 (<<,>>)
 *           = ***비교연산자 (==,!,<,>,<=,>=)
 *           = ***논리연산자 (&&,||)
 *           = ***대입연산자 (=,+=,-=, ...) 
 *      1-3) 삼항연산자
 *      	 = 조건 ? 값1:값2
 *      	 = 조건 true ==> 값1
 *      	 = 조건 false ==> 값2
 *    2) 연산방법
 *      2-1) 단항연산자
 *      	 = 증감연산자
 *      	 ++ : 무조건 1개를 증가한다
 *      	 -- : 무조건 한개를 감소한다
 *           사용법
 *           int a = 10; 변수선언
 *           ++10(안됨)
 *           ==> ++a(--a) : 전치연산자
 *           ==> a++(a--) : 후치연산자
 *           ==> 반복문 사용, 게임로직
 *           eg) for(int i=1,i<=100;i++)
 *           증감연산자는 반복문에서 많이 쓰인가
 *           연산을 쓰는 이유는 제어문을 활용하기해 위해서
 *           
 *           전치연산자 : 증가한 다음 개입
 *           int a = 10
 *           int b = ++a
 *           a = 11, b = 11
 *           
 *           후치연산자: 대입을 먼저하고 나중에 증가
 *           int a=10;
 *           int b = a++
 *           1 2
 *           ==> b=a ===> b=10
 *           ==> a++ ===> a=11
 *            
 *        2-2) 부정연산자(true=>false, false=>true) ==> !
 *            반드시 boolean을 사용한다. 
 *            
 *             예)
 *             boolean bcheck=false;
 *             !bcheck
 *             system.out.println(bcheck)
 *             
 *             자동으로 메모리를 바꾸는건지 아닌지 봐야함
 *             !는 자동으로 바뀌는 것이 아니다
 *             ++,--는 자동으로 바꾼다.
 *             
 *             boolean bcheck=false;
 *             bcheck=!bcheck (이렇게 정의를 해줘야 한다, 바뀐값을 받아야 줘야 한다.)
 *             system.out.println(bcheck)
 *             
 *             
 *
 *    3) 연산자 우선순위
 *    
 *    3+4*5 = 23 (우선순위가 있다. 곱셈 먼저. 나중에 and or 중 and가 우선)
 *    (3+4)*5 = 35 (괄호가 가장 높은 우선순위)
 *    
 *    증감연산자가 +보다 더 우선이다
 *    
 *    
 *     
 */

public class 단항연산자_증감연산자 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * int a=100; System.out.println(a+200); // a=300 System.out.println(a); //
		 * a=100 값저장 안해서 (부정연산자는 항상 값저장을 해줘야 한다)
		 */	
		
		boolean bCheck=false;
		System.out.println(bCheck);
		bCheck=!bCheck; // 값 저장해야지 이후에 영향을 미침
		System.out.println(bCheck); // 메모리까지 바뀌는 것이 아니다
		System.out.println(bCheck); // 값 저장 않하면 false로 나옴
		
		//전치 연산 
		int a=10;
		int b=++a;
		System.out.println("a="+a+",b="+b);
		
		//후치 연산
		a=10; // int빼고 하면 메모리 재사용
		b=a++;
		System.out.println("a="+a+",b="+b);
		
		a=32000;
//	    b=++a + ++a + ++a + ++a; //32004 b= 32001 32002 32003 32004 
        b=a++ + a++ + a++ + a++; //32004 b= 32000 32001 32002 32003
		System.out.println("a="+a+",b="+b);
		
		
	}

}
